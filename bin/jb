#!/usr/bin/env node
var exec = require("child_process").exec;
var spawn = require("child_process").spawn;
var argv = require('optimist').argv;
var config = require('../config');
var _ = require('underscore');
var fs = require('fs');
var colors = require('colors');
var async = require('async');
var util = require('util');
if(argv["m"]){
  process.env.NODE_ENV = argv["m"];
}
var environment = require('../lib/environment')(argv["m"]);
if(config.db[environment].adapter == "mysql"){
  var mysql = require('../mysql');
} else {
  var models = require('../models');
  models.emitter.on('open', function(){
    console.log('fadfadfad');
  });
}

function print_help(){
  console.log('--------------------------');
  console.log('     LIST OF COMMANDS');
  console.log('--------------------------');
  console.log('Note: valid modes are development, test, and production. Defaults to development.');
  console.log('');
  console.log('start [-m <mode>]');
  console.log('   * Start the job_board daemon');
  console.log('');
  console.log('stop');
  console.log('   * Stop the job_board daemon');
  console.log('');
  console.log('add receiver <name> <host> [-i <ip_address>] [-c <concurrency>] [-p <port>] [-m <mode>]');
  console.log('   * Add a receiver for the given host');
  console.log('');
  console.log('add path <receiver_name> <name> <url> [-t <timeout>] [-m <mode>]');
  console.log('   * Add an endpoint path for the given receiver.');
  console.log('');
  console.log('update receiver <name> [-n <new_name>] [-h <host>] [-i <ip_address>] [-c <concurrency>] [-p <port>] [-m <mode>]');
  console.log('   * Update given receiver');
  console.log('');
  console.log('update path <receiver_name> <name> [-n <new_name>] [-u <url>] [-t <timeout>] [-m <mode>]');
  console.log('   * Update given path');
  console.log('');
  console.log('ls [-r <receiver_name>] [-m <mode>]');
  console.log('   * List receivers and paths');
  console.log('');
  console.log('status [-r <receiver_name>] [-m <mode>]');
  console.log('   * List current jobs');
  console.log('');
  console.log('remove receiver <name> [-m <mode>]');
  console.log('   * Remove given receiver, and all children paths');
  console.log('');
  console.log('remove path <receiver_name> <name> [-m <mode>]');
  console.log('   * Remove given path');
  console.log('');
  console.log('remove all [-m <mode>]');
  console.log('   * Remove all data from database');
  console.log('');
  console.log('rewind');
  console.log('');
  console.log('help');
  console.log('   * Display this dialog');
  console.log('');
}

function parent_dir(){
  var dir_split = __dirname.split('/');
  return dir_split.slice(0,dir_split.length - 1).join('/');
}

function execute_command(commands){
  var command = process.argv[2];
  if(_.include(Object.keys(commands), command)){
    commands[command]();
  } else {
    print_help();
    //process.exit();
  }
}
// jb start -p 3030 -c jb_conf
commands = {
  start:function(port){
    exec('ps aux | grep '+ parent_dir() +'/job_board.js | grep -v grep | wc -l', function(error, stdout){
      if(error){
        console.log("ERROR: Job Board could not start: " + error);
      }
      if(stdout.trim() == '0'){
        exec('which mobettah | wc -l', function(error, stdout){
          if(stdout.trim() == '0'){
            var mobettah_cmd = parent_dir() + "/node_modules/mobettah/bin/mobettah";
          } else {
            var mobettah_cmd = "mobettah";
          }

          var preexec = "";
          if(argv['m']) process.env.NODE_ENV = argv.m;
          var child = spawn(mobettah_cmd, ['-c', parent_dir() + '/mobettah_config.js', parent_dir() + "/job_board.js"]);
          child.stdout.on('data', function(data){
            if(data.toString().indexOf("listening") != -1){
              console.log("Job Board process started");
              process.exit();
            }
          });
        });
      } else {
        console.log("ERROR: An instance of Job Board is already running.");
        process.exit();
      }
    });
  },
  
  stop:function(){
    fs.readFile("/tmp/mobettah.pid", function(err, data){
      if(err){
        console.log('ERROR: Could not stop job board: ' + err);
        process.exit();
      }
      exec("kill "+data.toString(), function(error, response){
        if(!error) {
          console.log("Job Board process stopped");
          process.exit();
        } else {
          console.log("ERROR: Job Board could not quit: " + error);
          process.exit();
        }
      });
    });
  },

  ls:function(){
    var options = {};
    if(argv.r){
      options.name = argv.r;
      console.log("List Receiver with name \""+argv.r+"\"");
    } else {
      console.log("List of Receivers");
    }
    console.log("");
    models.Receiver.find(options, function(err, docs){
      if(err){
        console.log(err);
        process.exit();
      }
      _.each(docs, function(doc){
        console.log(("["+doc.name.blue+"]").bold);
        console.log("  Host:          "+doc.host);
        if(doc.ip) console.log("  IP:            "+doc.ip);
        console.log("  Port:          "+doc.port);
        console.log("  Concurrency:   "+doc.concurrency);
        _.each(doc.paths, function(path){
          console.log("  â†’  Path Name:  "+path.name);
          console.log("     Timeout:    "+path.timeout);
          console.log("     URL:        "+path.url);
        })
        console.log("");
      })
      process.exit();
    });
  },
  
  add:function(){
    switch(process.argv[3]){
      case "receiver":
        var name = process.argv[4];
        var host = process.argv[5];
        var concurrency = Number(argv.c) || config.default_receiver_concurrency;
        var port = Number(argv.p) || config.default_receiver_port;

        if(!name || !host || !_.isNumber(concurrency) || !_.isNumber(port)){
          print_help();
          process.exit();
        }

        var options = {
          name: name,
          host: host,
          concurrency: concurrency,
          port: port
        };

        if(argv.i) options.ip = argv.i;

        var receiver = new models.Receiver(options);
        receiver.save(function(err){
          if(err){
            console.log('There has been an error saving this receiver.');
            process.exit();
          } else {
            console.log('You have saved this receiver.');
            console.log(options);
            process.exit();
          }
        });
        break;
      case "path":
        var o = {
          receiver_name: process.argv[4],
          name: process.argv[5],
          url: process.argv[6],
          timeout: Number(argv.t) || config.default_receiver_timeout
        };

        if(!o.receiver_name || !o.name || !o.url || !_.isNumber(o.timeout)){
          print_help();
          process.exit();
          return;
        }

        models.Receiver.find_by_name(o.receiver_name, function(err, receiver){
          if(err){
            console.log('There has been an error finding the record to add paths to');
            process.exit();
          }
          receiver.paths.push({name: o.name, url: o.url, timeout: o.timeout});
          receiver.save(function(err){
            if(err){
              console.log('There has been an error saving.');
              process.exit();
            }
            console.log('You have saved this path.');
            console.log(o);
            process.exit();
          });
        });
        break;
      default:
        print_help();
        process.exit();
    }
  },

  update:function(){
    switch(process.argv[3]){
      case "receiver":
        var name = process.argv[4];
        if(!name || !(argv.n || argv.h || _.isNumber(argv.c) || _.isNumber(argv.p) || argv.i)){
          print_help();
          process.exit();
        }
        models.Receiver.find_by_name(name, function(err, receiver){
          if(err){
            console.log('There has been an error finding the receiver to update.');
            process.exit();
          }
          if(argv.n) receiver.name = argv.n;
          if(argv.h) receiver.host = argv.h;
          if(argv.c) receiver.concurrency = Number(argv.c);
          if(argv.p) receiver.port = Number(argv.p);
          if(argv.i) receiver.ip = argv.i;
          receiver.save(function(err){
            if(err){
              console.log('There has been an error updating the receiver.');
              process.exit();
            }
            console.log('You have updated this receiver.');
            process.exit();
          });
        });
        break;
      case "path":
        var receiver_name = process.argv[4];
        var name = process.argv[5];
        if(!name || !receiver_name || !(argv.n || argv.u || _.isNumber(argv.t))){
          print_help();
          process.exit();
        }
        models.Receiver.find_by_name(receiver_name, function(err, receiver){
          if(err){
            console.log('There has been an error finding the receiver for the path to update.');
            process.exit();
          }
          var pathIndex = _.indexOf(receiver.paths, _.detect(receiver.paths, function(path){
            return path.name == name;
          }));
          if(pathIndex == -1){
            console.log('There has been an error finding the path to update.');
            process.exit();
          }
          if(argv.n) receiver.paths[pathIndex].name = argv.n;
          if(argv.u) receiver.paths[pathIndex].url = argv.u;
          if(argv.t) receiver.paths[pathIndex].timeout = Number(argv.t);
          receiver.save(function(err){
            if(err){
              console.log('There has been an error updating the path.');
              process.exit();
            }
            console.log('You have updated this path.');
            process.exit();
          });
        });
        break;
      default:
        print_help();
        process.exit();
    }
  },

  remove:function(){
    switch(process.argv[3]){
      case "receiver":
        var name = process.argv[4];
        if(!name){
          print_help();
          process.exit();
        }
        models.Receiver.find_by_name(name, function(err, receiver){
          if(err){
            console.log('There has been an error finding the receiver to remove.');
            process.exit();
          }
          receiver.remove(function(err){
            if(err){
              console.log(err);
            } else {
              console.log('You have removed this receiver.');
            }
            process.exit();
          });
        });
        break;
      case "path":
        var receiver_name = process.argv[4];
        var name = process.argv[5];
        if(!name || !receiver_name){
          print_help();
          process.exit();
        }
        models.Receiver.find_by_name(receiver_name, function(err, receiver){
          if(err){
            console.log('There has been an error finding the receiver for the path to remove.');
            process.exit();
          }
          var pathIndex = _.indexOf(receiver.paths, _.detect(receiver.paths, function(path){
            return path.name == name;
          }));
          if(pathIndex == -1){
            console.log('There has been an error finding the path to remove.');
            process.exit();
          }
          receiver.paths[pathIndex].remove();
          receiver.save(function(err){
            if(err){
              console.log('There has been an error removing the path.');
              process.exit();
            }
            console.log('You have removed this path.');
            process.exit();
          });
        });
        break;
      case "all":
        models.Receiver.collection.conn.db.dropDatabase(function(err){
          if(err){
            console.log(err);
          } else {
            console.log('All records dropped from database.');
          }
          process.exit();
        });
        break;
        /*
        async.parallel([
          function(done){
            models.Receiver.collection.drop(function(err){
              if(err) done(err);
              done();
            });
          }
        ], function(err, results){
          if(err){
            console.log(err);
          } else {
            console.log('All records dropped from database.');
          }
          process.exit();
        });
        */
      default:
        print_help();
        process.exit();
    }
  },

  status:function(){
    var receiver_name_mapping = {};
    if(argv.r){
      options.name = argv.r;
      console.log("List of Current Jobs with Receiver: \""+argv.r+"\"");
      var q = models.Job.find({
        'receiver.name': argv.r
      }).or([{status: "overflow"},{status: "queued"}]).sort('created', 'ascending');
    } else {
      console.log("List of Current Jobs");
      var q = models.Job.find({}).or([{status: "overflow"},{status: "queued"}]).sort('created', 'ascending');
    }

    q.execFind(function(err, jobs){
      if(err){
        console.log(err);
      } else {
        var receiver_lookups = {};
        _.each(jobs, function(job){
          receiver_lookups[job.receiver] = function(done){
            models.Receiver.findOne({'_id': job.receiver}, function(err, doc){
              if(err){
                done(err);
              } else {
                console.log(doc);
                receiver_name_mapping[job.receiver] = doc.name;
                done();
              }
            });
          };
        });
        async.parallel(receiver_lookups, function(err){
          var x = 0;
          _.each(jobs, function(job){
            x++;
            console.log();
            console.log("Job #" + x + ":");
            console.log("   Receiver:  "+receiver_name_mapping[job.receiver]);
            console.log("   Path:      "+job.path);
            console.log("   Post Data: "+job.payload);
            console.log("   Status:    "+job.status);
          });
          process.exit();
        });
      }
    });
  },
  
  rewind:function(){}
}

execute_command(commands);
